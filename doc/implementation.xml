<chapter>
  <title>Implementation</title>
  
  <sect1><title>Server Side</title>

    <para>
    </para>

    <sect2 id="ssip_commands"><title>SSIP Commands</title>
      <para>
      </para>
    </sect2>

    <sect2 id="shared_library_api"><title>Public API for shared library</title>
      <sect3><title>Basic functions</title>
        <variablelist>
          <varlistentry>
            <term> int speechd_init(char* client_name, char* conn_name); </term>
             <listitem>
            <para>
             Initiates new Speech Deamon session.
             Returns connection socket number or 0 if some error occured.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> void speechd_close(int fd); </term>
             <listitem>
            <para>
             Closes active speechd session.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int speechd_get_client_id(int fd); </term>
             <listitem>
            <para>
             Returns id of client on the given fd or 0 if
             nobody is connected on this fd.
            </para>
            </listitem>
          </varlistentry>

        </variablelist>
      </sect3>

      <sect3><title>Message manipulation functions</title>
        <variablelist>
          <varlistentry>
            <term> int speechd_say(int fd, int priority, char* text); </term>
             <listitem>
            <para>
              Speech Deamon receives given text and says it
              as soon as possible according to it's priority.
              On success, it returns 1, otherwise 0.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int speechd_sayf(int fd, int priority, char *text, ...) </term>
             <listitem>
            <para>
             Same as speechd_say() but the input text can
             be formated with the same technique as printf
             uses. (in fact, it calls printf internally).
             On success, it returns 1, otherwise 0.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int speechd_stop(int fd); </term>
             <listitem>
            <para>
              Stops speaking and cancels all queued messages for
              client on socket fd.
              Returns 1 on succes, 0 if there is no client on fd.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int speechd_pause(int fd); </term>
             <listitem>
            <para>
             Pauses messages from client connected on given fd. 
             This means that it *cancels* currently spoken message
             and *waits* with all others queued or received messages
             until speechd_resume(fd) is called.  Returns 1 on succes,
             0 if there is no client on fd.
            </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term> int speechd_resume(int fd); </term>
             <listitem>
            <para>
             Unpauses paused messages. Speech Deamon will continue
             saying them according to their priority.
             Returns 1 on succes, 0 if there is no client on fd.
            </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>

      <sect3><title>Speech synthesis parameters</title>
        <variablelist>
          <varlistentry>
            <term> int set_language(char* language); </term>
             <listitem>
            <para>

            </para>
            </listitem>
          </varlistentry>

        </variablelist>
      </sect3>

      <sect3><title>History functions</title>
        <variablelist>
          <varlistentry>
            <term> int speechd_history_get_client_list(char **client_list, int **id, int *num); </term>
            <listitem>
            <para>
             This command retrieves list off all active and inactive
             clients that are present in the history tree. You can
             imagine these clients as branches of the tree in which
             we have stored lists of messages. There is stored an array
             of strings with names of each client in client_list adress,
             array of all corresponding id's of these clients and
             the number of records in these arrays.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int speechd_history_get_last(int fd, int *id, time_t *time, int *client_id); </term>
            <listitem>
            <para>
             Finds the last message spoken (acording to time)
             and gives it's ID, time and client identificator.
             It returns 1 on succes, 0 if there are no messages
             in history list.
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
             int speechd_history_cursor_set_pos(int fd, int pos); <br/>
             int speechd_history_cursor_set_first(int fd); <br/>
             int speechd_history_cursor_set_last(int fd); <br/>
             int speechd_history_cursor_next(int fd); <br/>
             int speechd_history_cursor_prev(int fd);
            </term>
            <listitem>
            <para>
             This is a family of commands that provide a simple interface
             for browsing through messages in history. Client can set
             cursor to some place, move it forward and backward and
             get the message that the cursor is pointing on. Each one
             of them returns the position the cursor is set to or
             0 if the command fails (eg. position out of range).
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int speechd_history_cursor_get(int fd, int *id, time_t *time); </term>
             <listitem>
            <para>
             This command simply retrieves ID and time of the message
             the cursor is pointing on. It returns 1 on succes, 0 if
             (TODO: Is there such situation when this could happen?).
            </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> int speechd_history_say_id(int fd, int id); </term>
             <listitem>
            <para>

             Says message from history that belongs to the client
             the cursor is pointing on and has this given id.
             It returns 1 on succes, 0 if there is no such message.

            </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term> int speechd_history_say_text(int fd, char *text); </term>
             <listitem>
            <para>
             Says unspecified text that is not intended to be put
             in history again. This happens for history (we don't
             want to have history of history) but maybe there are
             other uses. It returns 1 on succes,
             0 if there is some error (TODO: What errors?).
            </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>


    </sect2> 

    <sect2><title>Configuration</title>

      <para>
	We use DotConf libray for loading the configuration files.
      </para>

    </sect2>
    
    <sect2><title>Output Modules</title>
      
      <para>
      </para>

    </sect2>
    
  </sect1>
  
  <sect1><title>Client Side</title>
    
    <para>
    </para>
    
  </sect1>
  
</chapter>
